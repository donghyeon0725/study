[출처](https://chanhuiseok.github.io/posts/cs-2/)


## 📌 데드락이란?

---

운영체제에서 데드락이란 시스템 자원에 대한 요구가 뒤엉킨 상태입니다.
즉, 둘 이상의 프로세스가 다른 프로세스가 점유한 자원을 서로 기다릴 때 무한정 대기상태에 빠지는 것을 의미합니다.

## 📌 데드락 발생 조건

---

데드락이 발생하기 위해서는 아래 네가지 조건을 만족해야 합니다.

- 상호배제
    - 한번에 하나의 프로세스에서만 사용할 수 있기 때문에, 다른 프로세스는 자원 사용이 끝날 때까지 기다려야 한다
- 점유대기
    - 자원을 보유하는 프로세스가 최소 1개 이상 있어야 하고, 이를 기다리는 또 다른 프로세스가 있어야 한다.
- 비선점
    - 이미 할당된 자원은 강제로 뺏을 수 없다.
- 순환대기
    - 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.


## 📌 데드락 해결 방법

---

데드락의 해결법은 크게 3가지로 분류할 수 있습니다.

- 데드락 발생을 **예방**하기
- 데드락 발생 가능성을 인정하고 **회피**하기
- 데드락 발생은 허용하고, 데드락을 **탐지하여** **데드락에서 회복**하기

## 📌 데드락 예방하기

---

데드락 발생 조건 4가지 중 하나라도 발생하지 않게 하는 것

- **자원의 상호 배제 조건** 방지 : 한 번에 여러 프로세스가 공유 자원을 사용할 수 있게 합니다.
    - 그러나 추후 동기화 관련 문제가 발생할 수 있습니다.
- **점유 대기 조건 방지** : 프로세스 실행에 필요한 모든 자원을 한꺼번에 요구하고 허용할 때까지 작업을 보류해서, 나중에 또다른 자원을 점유하기 위한 대기 조건을 성립하지 않도록 합니다.
- **비선점 조건 방지** : 이미 다른 프로세스에게 할당된 자원이 선점권이 없다고 가정할 때, 높은 우선순위의 프로세스가 해당 자원을 선점할 수 있도록 합니다.
- **순환 대기 조건 방지** : 자원을 순환 형태로 대기하지 않도록 일정한 한 쪽 방향으로만 자원을 요구할 수 있도록 합니다.

이런 조건을 방지해서 데드락을 예방하면 시스템 처리량이나 효율성을 떨어트리는 단점이 있을 수 있음.

데드락 회피법은 조금 덜 제한적인 방법으로 예방법의 단점 일부를 해결할 수 있음

## 📌 데드락 회피

---

데드락 회피에서는 Safe Sequence, Safe State 가 핵심 키워드

프로세스가 요청하는 모든 자원을, 데드락을 발생시키지 않고 모두 나누어 줄 수 있다면 Safe State (안정상태) 에 있다고 합니다.

프로세스에 특정 순서대로 자원을 할당, 실행 및 종료 했을 때 데드락이 발생하지 않는 순서가 있다면 이를 Safe Sequence (안전 순서) 라고 부릅니다.

이처럼 데드락을 회피하기 위해서(Safe State 를 유지하는) Safe Sequence 를 찾는 알고리즘으로 대표적인 것이 “은행원 알고리즘" 입니다.

## 📌 ****은행원 알고리즘(Banker’s Algorithm)****

---

다익스트라가 제안한 기법으로 자원의 할당을 결정하기 전에, 결정된 모든 자원의 최대 할당량을 가지고 계산해서 Safe State 에 들 수 있는지 여부를 검사합니다. 예를 들어보겠습니다.

**시스템이 사용가능한 총 자원의 수 : 12개**

| (t=t0) | Max | Allocation | Need | Available |
| --- | --- | --- | --- | --- |
| P0 | 10 | 5 | 5 |  |
| P1 | 4 | 2 | 2 |  |
| P2 | 9 | 2 | 7 |  |
- P0 ~ P2 : 프로세스
- Max : 각 프로세스가 요청하는 자원의 최대량
- Allocation : 현재 프로세스가 사용중인 자원의 량
- Need : 처리를 남은 필요한 자원의 양

P0 ~ P2 프로세스가 모두 작업을 시작할 때, 현재 남은 자원의 양(Available)은 3개[12 - (5 + 2 + 2)] 입니다.

이 때, Safe State 에 들 수 있는 Safe Sequence 는 P1, P0, P2 순서로 실행하는 것입니다.

1. 남은 3개의 자원 중, P1 이 먼저 처리를 위해 2개(Allocation) 의 자원을 할당 받습니다. 이 때 남은 자원은 1개(3 - 2)입니다. 그리고 처리가 끝나면 모든 자원(4개)를 반환하므로 남은 자원은 5개가 될 것입니다.
2. 그리고 P0 이 처리를 위해서 5개의 자원을 요청합니다. 남은 자원은 0개(5 - 5)입니다. 그리고 처리가 끝나면 모든 자원을 반환하므로 남은 자원은 10개가 될 것입니다.
3. P2 가 처리를 위해서 7개의 자원을 요청합니다. 남은 자원은 3개 (10 - 7) 입니다. 처리가 끝나면 모든 자원을 반환하므로 12개가 될 것 입니다.

이 순서대로 처리하면 자원의 부족함없이 처리할 수 있습니다.

그런데, 만약 P2 의 Allocation 이 3이었다면, P1 프로세스가 작업을 마치고 남은 자원의 수가 4개 (0 + 4)가 되므로, P0 또는 P1 프로세스는 작업을 진행할 수 없습니다.

따라서 P0 또는 P1 프로세스는 자원을 할당 받기 위해서 계속 기다려야 합니다.

은행원 알고리즘을 사용하면 자원할당량을 사전에 미리 파악하고 해결할 수 있지만, 이를 계산하기 위해 별도의 프로세스에서 자원을 사용한다는 단점이 있고, 미리 자원의 최대 요구량 등을 알아야 한다는 제약조건이 있습니다.

## 📌 데드락 탐지 및 회복

---

데드락 예방이나, 회피 기법을 사용하지 않았다면 데드락이 발생할 수 있는데 여기에 데드락 탐지 및 회복 기법을 사용해서 극복할 수도 있습니다.

- 탐지 기법
    - Allocation, Request, Available 등으로 은행원 알고리즘에서 그랬던 것 처럼 데드락이 발생했는지 여부를 확인합니다.
    - 이 외에도 **자원 할당 그래프를 통해 탐지**하는 방법도 있습니다.
- 회복 기법
    - 프로세스를 1개 이상 종료 시키기
        - 교착 상태의 모든 프로세스 종료 시키기
            - 연산중이던 프로세스들도 모두 중단되어 부분 결과가 폐기될 수 있는 문제점이 발생할 수 있음
        - 프로세스를 하나씩 중단시키면서 다시 데드락 상태에 빠지는지 검사하는 방법
            - 매번 탐지 알고리즘을 호출해야 해서 부담이 될 수 있다는 단점
    - 자원 선점하기
        - 프로세스에 할당된 자원을 다른 자원이 선점해서 사용할 수 있도록 하는 방법
